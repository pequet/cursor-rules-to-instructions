#!/bin/bash

# Standard Error Handling
set -e
set -u
set -o pipefail

# --- Logging Toggle (disabled until log dir ensured) ---
LOGGING_ENABLED=0

# █   █  IDE Rules Synchronizer: Multi-Target Rule Conversion Tool
#  █ █   Version: 3.0.0
#  █ █   Author: Benjamin Pequet
# █   █  GitHub: https://github.com/pequet/cursor-rules-to-instructions/
#
# Purpose:
#   Synchronizes master rules to multiple AI coding assistant formats.
#   Generates documentation files (AGENTS.md, ARCHITECTURE.md, RULES.md) and 
#   AI-specific files (CLAUDE.md, GEMINI.md) from templates in assets/.
#   Creates individual rule files for different IDE assistants (.cursor/rules/*.mdc, .github/instructions/*.instructions.md)
#
# Usage:
#   ./sync-ide-rules.sh --from <source_dir> --to <targets>
#   --from <source_dir>: Directory containing master rule files (default: master-rules)
#   --to <targets>: Comma-separated list of targets (cursor,github,claude,gemini,docs) (default: all)
#
# Dependencies:
#   - Bash 4.0+
#   - Standard Unix utilities (find, sed, awk, grep)
#   - scripts/utils/messaging_utils.sh
#   - scripts/utils/logging_utils.sh
#
# Changelog:
#   3.0.0 - 2025-08-29 - Refactored to support multi-agent docs and a simpler approach
#   2.0.0 - 2025-08-29 - Major refactoring to support multiple targets
#   1.0.0 - 2025-08-17 - Initial release
#
# Support the Project:
#   - Buy Me a Coffee: https://buymeacoffee.com/pequet
#   - GitHub Sponsors: https://github.com/sponsors/pequet


# --- Global Variables ---
# Resolve the true script directory, following symlinks
SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
SCRIPT_DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null 2>&1 && pwd )"
PROJECT_ROOT="$( cd -P "$( dirname "$SCRIPT_DIR" )" >/dev/null 2>&1 && pwd )"

# --- Utility Scripts ---
source "${SCRIPT_DIR}/utils/logging_utils.sh"
source "${SCRIPT_DIR}/utils/messaging_utils.sh"

# --- Configuration ---
# Processing statistics
declare -i FILES_PROCESSED=0
declare -i FILES_CONVERTED=0
declare -i FILES_SKIPPED=0
declare -i ERRORS_COUNT=0

# --- Asset Paths ---
ASSETS_DIR="${PROJECT_ROOT}/assets"

# --- Logging Configuration ---
SCRIPT_NAME=$(basename "$0" .sh)
LOG_FILE_PATH="${SCRIPT_DIR}/logs/${SCRIPT_NAME}.log"

# --- Function Definitions ---

# *
# * Utility and Setup Functions
# *

validate_dependencies() {
    local required_commands=("find" "sed" "awk" "grep")
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "${cmd}" &> /dev/null; then
            print_error "Required command not found: ${cmd}"
            exit 1
        fi
    done
}

show_usage() {
    echo "Usage: $0 [--from <source_dir>] [--to <targets>]"
    echo ""
    echo "Synchronize master rules to multiple AI coding assistant formats"
    echo ""
    echo "Arguments:"
    echo "  --from <source_dir>  Directory containing master rule files (default: master-rules)"
    echo "  --to <targets>       Comma-separated list of targets (cursor,github,claude,gemini,docs) (default: all)"
    echo ""
    echo "Examples:"
    echo "  $0 --from master-rules --to cursor,github"
    echo "  $0 --to claude,gemini"
    echo "  $0 --to docs"
}

backup_file() {
    local file_path="$1"
    
    if [[ -f "$file_path" ]]; then
        local backup_file="${file_path}.bak"
        cp "$file_path" "$backup_file"
        log_message "INFO" "Backed up existing file: $file_path to $backup_file"
        return 0
    else
        return 1
    fi
}

# *
# * Target Generation Functions
# *

# Create cursor .mdc files
generate_cursor_files() {
    local source_dir="$1"
    local cursor_rules_dir="$2"
    
    print_step "Processing target: Cursor"
    log_message "INFO" "Processing target: Cursor"
    
    # Create target directory if it doesn't exist
    mkdir -p "$cursor_rules_dir"
    
    # Find all source files
    while IFS= read -r -d '' source_file; do
        ((FILES_PROCESSED++))
        local basename_file=$(basename "$source_file")
        local dest_file="${cursor_rules_dir}/${basename_file%.md}.mdc"
        
        # Backup existing file
        backup_file "$dest_file"
        
        # Simple copy with extension change - assumes master rules are already in correct format
        # In a real implementation, you might process the file here
        cp "$source_file" "$dest_file"
        
        print_info "Generated: ${dest_file#${PROJECT_ROOT}/}"
        log_message "SUCCESS" "Generated Cursor file: $dest_file"
        ((FILES_CONVERTED++))
    done < <(find "$source_dir" -name "*.md" -type f -print0)
}

# Create GitHub Copilot .instructions.md files
generate_github_files() {
    local source_dir="$1"
    local github_instructions_dir="$2"
    
    print_step "Processing target: GitHub Copilot"
    log_message "INFO" "Processing target: GitHub Copilot"
    
    # Create target directory if it doesn't exist
    mkdir -p "$github_instructions_dir"
    
    # Find all source files
    while IFS= read -r -d '' source_file; do
        ((FILES_PROCESSED++))
        local basename_file=$(basename "$source_file")
        local dest_file="${github_instructions_dir}/${basename_file%.md}.instructions.md"
        
        # Backup existing file
        backup_file "$dest_file"
        
        # Convert frontmatter and copy content
        # For simplicity, assuming a simple copy with extension change
        # In a full implementation, you would process frontmatter here
        cp "$source_file" "$dest_file"
        
        print_info "Generated: ${dest_file#${PROJECT_ROOT}/}"
        log_message "SUCCESS" "Generated GitHub Copilot file: $dest_file"
        ((FILES_CONVERTED++))
    done < <(find "$source_dir" -name "*.md" -type f -print0)
}

# Create CLAUDE.md
generate_claude_file() {
    local source_dir="$1"
    local claude_file="$2"
    local claude_template="${ASSETS_DIR}/CLAUDE.md"
    
    print_step "Creating Claude file: ${claude_file#${PROJECT_ROOT}/}"
    log_message "INFO" "Processing target: Claude"
    
    # Check if template exists
    if [[ ! -f "$claude_template" ]]; then
        print_error "Claude template not found: ${claude_template#${PROJECT_ROOT}/}"
        log_message "ERROR" "Claude template not found: $claude_template"
        ((ERRORS_COUNT++))
        return 1
    fi
    
    # Backup existing file
    backup_file "$claude_file"
    
    # Copy template to destination
    cp "$claude_template" "$claude_file"
    
    # Find all rule files
    local rule_files=()
    while IFS= read -r -d '' file; do
        rule_files+=("$file")
    done < <(find "${source_dir}" -name "*.md" -type f | sort -n)
    
    if [[ ${#rule_files[@]} -eq 0 ]]; then
        print_warning "No rule files found in: ${source_dir#${PROJECT_ROOT}/}"
        log_message "WARNING" "No rule files found in: $source_dir"
        return 0
    fi
    
    print_info "Found ${#rule_files[@]} rule file(s) to process"
    log_message "INFO" "Found ${#rule_files[@]} rule files for Claude"
    
    # Append each rule to the Claude file with proper heading format
    for rule_file in "${rule_files[@]}"; do
        ((FILES_PROCESSED++))
        local basename_rule=$(basename "${rule_file}")
        
        print_info "Adding ${basename_rule} to Claude file"
        
        # Extract rule ID and title (assuming format like 1001-rule-name.md)
        local rule_id
        local title
        
        # Try to extract ID from filename (assumes format like 1001-rule-name.md)
        if [[ $basename_rule =~ ^([0-9]+)- ]]; then
            rule_id="${BASH_REMATCH[1]}"
            # Extract title from file (first heading)
            title=$(grep -m 1 "^# " "$rule_file" | sed 's/^# //')
            
            # If no title found, use filename without extension and ID
            if [[ -z "$title" ]]; then
                title="${basename_rule#${rule_id}-}"
                title="${title%.md}"
            fi
        else
            # If no ID found, just use the title
            rule_id=""
            title=$(grep -m 1 "^# " "$rule_file" | sed 's/^# //')
            
            # If no title found, use filename without extension
            if [[ -z "$title" ]]; then
                title="${basename_rule%.md}"
            fi
        fi
        
        # Add rule to Claude file with proper heading format
        if [[ -n "$rule_id" ]]; then
            echo "## [${rule_id}] ${title}" >> "$claude_file"
        else
            echo "## ${title}" >> "$claude_file"
        fi
        echo "" >> "$claude_file"
        
        # Extract content after frontmatter
        local in_frontmatter=false
        local frontmatter_count=0
        
        while IFS= read -r line; do
            if [[ "$line" == "---" ]]; then
                if [[ "$in_frontmatter" == false ]]; then
                    in_frontmatter=true
                    ((frontmatter_count++))
                else
                    in_frontmatter=false
                    ((frontmatter_count++))
                fi
                continue
            fi
            
            # Skip frontmatter content
            if [[ "$in_frontmatter" == true ]]; then
                continue
            fi
            
            # Skip initial heading (already used as section title)
            if [[ "$frontmatter_count" -eq 2 && "$line" =~ ^#[[:space:]] ]]; then
                frontmatter_count=3  # Mark that we've processed the heading
                continue
            fi
            
            # Add all other content
            echo "$line" >> "$claude_file"
        done < "$rule_file"
        
        # Add separator between rules
        echo "" >> "$claude_file"
        
        ((FILES_CONVERTED++))
    done
    
    print_info "Claude file created successfully: ${claude_file#${PROJECT_ROOT}/}"
    log_message "SUCCESS" "Created Claude file: $claude_file with ${#rule_files[@]} rules"
}

# Create GEMINI.md
generate_gemini_file() {
    local source_dir="$1"
    local gemini_file="$2"
    local gemini_template="${ASSETS_DIR}/GEMINI.md"
    
    print_step "Creating Gemini file: ${gemini_file#${PROJECT_ROOT}/}"
    log_message "INFO" "Processing target: Gemini"
    
    # Check if template exists
    if [[ ! -f "$gemini_template" ]]; then
        print_error "Gemini template not found: ${gemini_template#${PROJECT_ROOT}/}"
        log_message "ERROR" "Gemini template not found: $gemini_template"
        ((ERRORS_COUNT++))
        return 1
    fi
    
    # Backup existing file
    backup_file "$gemini_file"
    
    # Copy template to destination
    cp "$gemini_template" "$gemini_file"
    
    # Find all rule files
    local rule_files=()
    while IFS= read -r -d '' file; do
        rule_files+=("$file")
    done < <(find "${source_dir}" -name "*.md" -type f | sort -n)
    
    if [[ ${#rule_files[@]} -eq 0 ]]; then
        print_warning "No rule files found in: ${source_dir#${PROJECT_ROOT}/}"
        log_message "WARNING" "No rule files found in: $source_dir"
        return 0
    fi
    
    print_info "Found ${#rule_files[@]} rule file(s) to process"
    log_message "INFO" "Found ${#rule_files[@]} rule files for Gemini"
    
    # Append each rule to the Gemini file with proper heading format
    for rule_file in "${rule_files[@]}"; do
        ((FILES_PROCESSED++))
        local basename_rule=$(basename "${rule_file}")
        
        print_info "Adding ${basename_rule} to Gemini file"
        
        # Extract rule ID and title (assuming format like 1001-rule-name.md)
        local rule_id
        local title
        
        # Try to extract ID from filename (assumes format like 1001-rule-name.md)
        if [[ $basename_rule =~ ^([0-9]+)- ]]; then
            rule_id="${BASH_REMATCH[1]}"
            # Extract title from file (first heading)
            title=$(grep -m 1 "^# " "$rule_file" | sed 's/^# //')
            
            # If no title found, use filename without extension and ID
            if [[ -z "$title" ]]; then
                title="${basename_rule#${rule_id}-}"
                title="${title%.md}"
            fi
        else
            # If no ID found, just use the title
            rule_id=""
            title=$(grep -m 1 "^# " "$rule_file" | sed 's/^# //')
            
            # If no title found, use filename without extension
            if [[ -z "$title" ]]; then
                title="${basename_rule%.md}"
            fi
        fi
        
        # Add rule to Gemini file with proper H2 heading format
        if [[ -n "$rule_id" ]]; then
            echo "## [${rule_id}] ${title}" >> "$gemini_file"
        else
            echo "## ${title}" >> "$gemini_file"
        fi
        echo "" >> "$gemini_file"
        
        # Extract content after frontmatter
        local in_frontmatter=false
        local frontmatter_count=0
        
        while IFS= read -r line; do
            if [[ "$line" == "---" ]]; then
                if [[ "$in_frontmatter" == false ]]; then
                    in_frontmatter=true
                    ((frontmatter_count++))
                else
                    in_frontmatter=false
                    ((frontmatter_count++))
                fi
                continue
            fi
            
            # Skip frontmatter content
            if [[ "$in_frontmatter" == true ]]; then
                continue
            fi
            
            # Skip initial heading (already used as section title)
            if [[ "$frontmatter_count" -eq 2 && "$line" =~ ^#[[:space:]] ]]; then
                frontmatter_count=3  # Mark that we've processed the heading
                continue
            fi
            
            # Add all other content
            echo "$line" >> "$gemini_file"
        done < "$rule_file"
        
        # Add spacing between rules
        echo "" >> "$gemini_file"
        echo "" >> "$gemini_file"
        
        ((FILES_CONVERTED++))
    done
    
    print_info "Gemini file created successfully: ${gemini_file#${PROJECT_ROOT}/}"
    log_message "SUCCESS" "Created Gemini file: $gemini_file with ${#rule_files[@]} rules"
}

# Copy documentation files
copy_doc_files() {
    local doc_files=("AGENTS.md" "ARCHITECTURE.md" "RULES.md")
    
    print_step "Processing target: Documentation Files"
    log_message "INFO" "Processing target: Documentation Files"
    
    for doc_file in "${doc_files[@]}"; do
        local source_file="${ASSETS_DIR}/${doc_file}"
        local dest_file="${PROJECT_ROOT}/${doc_file}"
        
        if [[ ! -f "$source_file" ]]; then
            print_error "Documentation template not found: ${source_file#${PROJECT_ROOT}/}"
            log_message "ERROR" "Documentation template not found: $source_file"
            ((ERRORS_COUNT++))
            continue
        fi
        
        # Backup existing file
        backup_file "$dest_file"
        
        # Copy template to destination
        cp "$source_file" "$dest_file"
        
        print_info "Copied ${doc_file} to project root"
        log_message "SUCCESS" "Copied documentation file: $doc_file"
        ((FILES_CONVERTED++))
    done
}

# *
# * Main Execution Functions
# *

print_summary() {    
    if [[ ${ERRORS_COUNT} -eq 0 ]]; then
        print_completed "Synchronization complete!"
    else
        print_error "Synchronization completed with ${ERRORS_COUNT} errors."
    fi
    
    print_info "Converted: ${FILES_CONVERTED} files"
    
    if [[ ${FILES_SKIPPED} -gt 0 ]]; then
        print_info "Skipped: ${FILES_SKIPPED} files"
    fi
    
    print_separator
    
    # Add next steps for the user
    print_info "Next steps:"
    print_info "1. Review the generated files in their respective locations:"
    print_info "   - Documentation: AGENTS.md, ARCHITECTURE.md, RULES.md"
    print_info "   - Cursor: .cursor/rules/"
    print_info "   - GitHub Copilot: .github/instructions/"
    print_info "   - Claude: CLAUDE.md"
    print_info "   - Gemini: GEMINI.md"
    print_info "2. Test with your preferred AI coding assistants"
    print_info "3. Make any necessary adjustments to the rule files"
}

main() {
    print_header "IDE Rules Synchronizer v3.0"
    ensure_log_directory
    enable_logging
    
    # Default values
    local source_dir="${PROJECT_ROOT}/master-rules"
    local targets="cursor,github,claude,gemini,docs"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --from)
                source_dir="${PROJECT_ROOT}/$2"
                shift 2
                ;;
            --to)
                targets="$2"
                shift 2
                ;;
            -h|--help)
                show_usage
                exit 0
                ;;
            *)
                print_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
    done
    
    # Check if source directory exists
    if [[ ! -d "$source_dir" ]]; then
        print_error "Source directory not found: ${source_dir#${PROJECT_ROOT}/}"
        print_error "Ensure your project has a master-rules/ directory with rule files."
        exit 1
    fi
    
    # Check if assets directory exists
    if [[ ! -d "$ASSETS_DIR" ]]; then
        print_error "Assets directory not found: ${ASSETS_DIR#${PROJECT_ROOT}/}"
        print_error "Ensure your project has an assets/ directory with template files."
        exit 1
    fi
    
    # Validate dependencies
    validate_dependencies
    
    # Log conversion start
    log_message "INFO" "Starting rules synchronization"
    log_message "INFO" "Project root: $PROJECT_ROOT"
    log_message "INFO" "Source directory: $source_dir"
    log_message "INFO" "Target formats: $targets"
    
    # Convert targets string to array
    IFS=',' read -ra target_array <<< "$targets"
    
    # Process each target
    for target in "${target_array[@]}"; do
        case "$target" in
            cursor)
                generate_cursor_files "$source_dir" "${PROJECT_ROOT}/.cursor/rules"
                ;;
            
            github)
                generate_github_files "$source_dir" "${PROJECT_ROOT}/.github/instructions"
                ;;
            
            claude)
                generate_claude_file "$source_dir" "${PROJECT_ROOT}/CLAUDE.md"
                ;;
            
            gemini)
                generate_gemini_file "$source_dir" "${PROJECT_ROOT}/GEMINI.md"
                ;;
            
            docs)
                copy_doc_files
                ;;
            
            *)
                print_warning "Unknown target: $target (skipping)"
                ((FILES_SKIPPED++))
                ;;
        esac
    done
    
    # Show results
    print_footer
    print_summary
    
    # Log completion
    if [[ ${ERRORS_COUNT} -eq 0 ]]; then
        log_message "INFO" "Synchronization completed successfully"
        exit 0
    else
        log_message "ERROR" "Synchronization completed with ${ERRORS_COUNT} errors"
        exit 1
    fi
}

# --- Script Entrypoint ---
main "$@"
